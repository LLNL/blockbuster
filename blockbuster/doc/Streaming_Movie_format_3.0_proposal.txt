        Version 2.0 is in the man page.  As of version 3.0, the streaming movie format 
        shall be as follows: 

      The  format consists of a header, a table of resolutions, a frameoffset table and 
      image data, optionally followed by arbitrary information we shall call "metadata."

      The file is to written as big endian to ensure cross-platform compatibility.  

      HEADER 
      The header consists of a total of 64 bytes, composed of "words" of various length, 
      plus a table of tiles
:
          (word) (bytes) meaning
          --------------------------------------------------------------------------------
            (00) (4)  uint32 Magic  (0x0f1e2d3e)  # for version 2.0, this was 0x0f1e2d3d
            (01) (4)  float32 Frame rate
            (02) (2)  uint16 Number of resolutions (max 20)
            (03) (2)  uint16 Flags (see discussion below)
            (04) (8)  uint64 Number of frames in the file
            (05) (8)  uint64 Movie frame width
            (06) (8)  uint64 Movie frame height
            (07) (28) 28 unused bytes, reserved for future use, shall be set to zero for now. 
          --------------------------------------------------------------------------------
            (08) (8n) One pair of uint64 values per resolution, indicating tile heights/widths. 
 
       The low order 8 bits of word 3, "Flags" field specifies the compression:  
       0x0000=none (RAW), 0x0001=RLE, 0x0002=zlib, 0x0003=lzo,    
       0x0004=jpg. The upper bits are other flags.  Currently defined
       flags: 0x0100 = Stereo.  0x0200 = Metadata exists.  See "Metadata" 
       discussion below.  If this flag is not set, then it is guaranteed that no metadata 
       of any sort will be stored in the movie.  

       SM 3.0 supports multiple resolutions of the movie in the same  file, just as version 
       2.0 did, but there is no limit on the number of levels.   The  number  of
       resolutions  are listed in the file header.

       The number of actual compressed frames in the file  is  equal  to  the  number  of
       frames  listed  in  the  header field times the number of resolutions in the file.
       Each frame can be decomposed into tiles. The  compression  algorithm  is  executed
       independently on each tile. The size of each tile is stored in the "Tile size" ta-
       ble in the header.  The X and Y sizes are both 64 bit unsigned integers, stored as 
       pairs, with X first. 

       FRAME OFFSETS AND FRAME DATA
       The header is followed by a table of offsets from the beginning of the sm file  to
       the  data  for  a  given frame.  These offsets are 64bit unsigned integers and there 
       is one integer for each frame times the number of resolutions in the  file.   The  offset
       table  is  followed  by  a table of compressed frame lengths.  This is an array of
       64bit unsigned integers, one for each frame times the number of resolutions in the
       file.

       There  are no ordering constraints on the fames in the file. Individual frames are
       not necessarily stored in a contiguous or sequential fashion. However, it is a 
       good idea for performance if they are in general practice. 

       Frames are considered to be 24bits/pixel.  A  given  frame  is  considered  to  be
       3bytes*frame  width*frame  height in size.  Data are laid out in pixel interleaved
       format (e.g. RGBRGBRGB...) from right to left and bottom to top  (default  glDraw-
       Pixels()  form).  No  padding is provided.  Each frame is passed to the compressor
       and the resulting output is placed in the file.   Details  on  the  specific  data
       organization for a given compression scheme may be found be referencing the appro-
       priate subclass.

       METADATA
       The metadata section shall begin at the first byte following the last frame of the 
       movie and continues to the end of the movie.  Metadata is a general term and can 
       include any arbitrary information, including binary payloads, that one might want
       to include with a movie.  The metadata is written  as follows. 
       Naturally, fields (2) and (4)  are big-endian.  

         (1) n bytes: <data payload: see below>
         (2) 8 bytes: uint64: payload length
         (3) 1014 bytes: <tag name: null terminated ASCII sequence> 
         (4) 8 bytes: uint64 : a binary signature constant 0x0088BBeecc113399

 
       This allows the metadata to be found simply by reading the last 8 bytes of the file, 
       confirming the binary signature (4), and reading field (3) to check if the tag is of
       interest.         
       If the tag name is not understood by the reader, the metadata item shall simply be 
       skipped.  
       You then can read the payload by seeking backwards and reading the data.  The next 
       metadata item is found by reading the   8 bytes preceding this one, and so on.  This
       backwards flow is convenient, flexible, and eliminates the need to store any more
       than just the metadata itself.  
       
       The data payload may theoretically in the future be of any format, including binary, 
       compressed,  "wrong" endian, etc.  However, currently supported payloads are all big 
       endian and start with a magic number and have the following formats: 
         METADATA_TYPE_ASCII:  8 bytes: magic number 0xA5C11A5C11A5C11A
                               8 bytes: uint64_t giving  length of null-terminated string
                               n bytes: null-terminated ASCII string,             
         METADATA_TYPE_DOUBLE: 8 bytes: magic number 0xF10A7F10A7F10A7F
                               8 bytes: double (FP64)
         METADATA_TYPE_INT64:  8 bytes: magic number 0x4244224442244442
                               8 bytes: long long (int64_t)



COMPRESSION SCHEMES
       Unchanged from version 2.0.  
