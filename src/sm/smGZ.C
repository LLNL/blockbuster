/*
** $RCSfile: smGZ.C,v $
** $Name:  $
**
** ASCI Visualization Project 
**
** Lawrence Livermore National Laboratory
** Information Management and Graphics Group
** P.O. Box 808, Mail Stop L-561
** Livermore, CA 94551-0808
**
** For information about this project see:
** 	http://www.llnl.gov/sccd/lc/img/
**
**      or contact: asciviz@llnl.gov
**
** For copyright and disclaimer information see:
**      $(ASCIVIS_ROOT)/copyright_notice_1.txt
**
** 	or man llnl_copyright
**
** $Id: smGZ.C,v 1.5 2009/05/19 02:52:19 wealthychef Exp $
**
*/
/*
**
**  Abstract:
**
**  Author:
**
*/


//
// smGZ.C
//
//
//
//

#include <stdlib.h>
#include "smGZ.h"
#include "zlib.h"

#define gzdbprintf fprintf(stderr, "%s line %d: ", __FILE__, __LINE__); fprintf

u_int smGZ::typeID = 2;

smGZ::smGZ(const char *_fname, int _nwin)
  :smBase(_fname, _nwin)
{
}

smGZ::~smGZ()
{
}

void smGZ::init(void)
{
   smBase::registerType(typeID, create);
}

smBase *smGZ::create(const char *_fname, int _nwin)
{
   return(new smGZ(_fname, _nwin));
}

void smGZ::decompBlock(u_char *cdata,u_char *image,int size,int *dim)
{
   int 	err;
   int  dlen;
   z_stream  stream;

   dlen = dim[0]*dim[1]*sizeof(u_char[3]);

   stream.zalloc = (alloc_func)0;
   stream.zfree = (free_func)0;
   stream.opaque = (voidpf)0;

   stream.next_in = cdata;
   stream.avail_in = size;
   stream.next_out = image;
   stream.avail_out = dlen;

   err = inflateInit(&stream);
   if (err != Z_OK) {
      gzdbprintf(stderr,"GZ decompression init error: %d\n",err);
      return;
   }

   while(err == Z_OK) {
      err = inflate(&stream, Z_NO_FLUSH);
   }
   if (err != Z_STREAM_END) {
      gzdbprintf(stderr,"GZ decompression error: %d\n",err);
   }

   err = inflateEnd(&stream);
   if (err != Z_OK) {
      gzdbprintf(stderr,"GZ decompression end error: %d\n",err);
      return;
   }

#if 0
   uLongf dlen;
   int  status;

   dlen = dim[0]*dim[1]*sizeof(u_char[3]);
   status = uncompress((Bytef *)image,&dlen,(Bytef *)cdata,size);
   if (status != Z_OK) {
	gzdbprintf(stderr,"GZ decompression error: %d\n",status);
   }
#endif

   return;
}

smGZ *smGZ::newFile(const char *_fname, u_int _nframes, 
	u_int _width, u_int _height, u_int *_tile, u_int _nres)
{
   smGZ *r = new smGZ(NULL);

   if (r->smBase::newFile(_fname, _nframes, _width, _height, _tile, _nres)) {
	delete r;
	r = NULL;
   }
 
   return(r);
}

void smGZ::compBlock(void *data, void *cdata, int &size,int *dim)
{
   int status;
   uLongf dlen,len;

   len = dim[0]*dim[1]*sizeof(u_char[3]);
   dlen = (len * (uLongf)1.1)+12;
   if (cdata) {
       status = compress((Bytef *)cdata,&dlen,(Bytef *)data,len);
       if (status != Z_OK) {
	   gzdbprintf(stderr,"GZ compression error: %d\n",status);
       }
   }
   size = dlen;
}
